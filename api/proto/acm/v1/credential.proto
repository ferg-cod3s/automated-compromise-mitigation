// Copyright 2025 ACM Project
// SPDX-License-Identifier: Apache-2.0

// Credential Remediation Service (CRS) API definitions.
// This service provides functionality for detecting compromised credentials,
// rotating passwords, and managing credential lifecycle in password managers.

syntax = "proto3";

package acm.v1;

import "acm/v1/common.proto";

option go_package = "github.com/ferg-cod3s/automated-compromise-mitigation/api/proto/acm/v1;acmv1";

// CredentialService provides credential management and remediation capabilities.
// This is the core service for ACM Phase I, handling:
// - Detection of compromised credentials in password vaults
// - Secure password generation
// - Automated credential rotation with vault updates
// - Rotation status tracking and verification
service CredentialService {
  // DetectCompromised queries the password manager for compromised credentials.
  // This method invokes the password manager CLI to identify credentials
  // that appear in known data breaches.
  //
  // Security: This method never accesses the master password or vault encryption keys.
  // It relies on the password manager's own breach detection capabilities.
  rpc DetectCompromised(DetectRequest) returns (DetectResponse);

  // RotateCredential performs a complete credential rotation workflow:
  // 1. Generates a new secure password based on policy
  // 2. Updates the password vault via CLI
  // 3. Verifies the update was successful
  // 4. Logs the rotation event to audit trail
  //
  // Security: Passwords are generated using crypto/rand and secured in memory
  // with mlock. The master password is never accessed.
  rpc RotateCredential(RotateRequest) returns (RotateResponse);

  // GetRotationStatus retrieves the current status of a credential rotation operation.
  // Useful for tracking long-running rotations or those requiring HIM intervention.
  rpc GetRotationStatus(StatusRequest) returns (StatusResponse);

  // ListCredentials retrieves all credentials from the password vault.
  // This is a read-only operation that returns credential metadata without passwords.
  //
  // Security: Password values are never returned by this method.
  rpc ListCredentials(ListRequest) returns (ListResponse);

  // GeneratePassword generates a secure password based on the specified policy.
  // This is a utility method that can be called independently of rotation.
  //
  // Security: Uses crypto/rand for cryptographically secure random generation.
  rpc GeneratePassword(GeneratePasswordRequest) returns (GeneratePasswordResponse);
}

// DetectRequest initiates a scan for compromised credentials.
message DetectRequest {
  // Request metadata for tracing and audit
  Metadata metadata = 1;

  // Password manager type to query
  PasswordManagerType password_manager_type = 2;

  // Optional filter to limit detection to specific domains or categories
  DetectionFilter filter = 3;

  // Force fresh check (bypass cache if password manager supports it)
  bool force_refresh = 4;
}

// DetectionFilter allows filtering compromised credential detection.
message DetectionFilter {
  // Filter by specific domains (e.g., ["github.com", "gmail.com"])
  repeated string domains = 1;

  // Filter by credential categories (e.g., ["login", "identity"])
  repeated string categories = 2;

  // Only return credentials last rotated before this timestamp (Unix seconds)
  int64 last_rotated_before = 3;

  // Only return credentials from breaches after this date (Unix seconds)
  int64 breach_date_after = 4;
}

// DetectResponse returns the list of compromised credentials found.
message DetectResponse {
  // Response status
  Status status = 1;

  // List of compromised credentials detected
  repeated CompromisedCredential credentials = 2;

  // Total count of compromised credentials
  int32 total_count = 3;

  // Timestamp when detection was performed (Unix seconds)
  int64 detection_timestamp = 4;

  // Password manager CLI version used for detection
  string cli_version = 5;

  // Error details if status is not SUCCESS
  Error error = 6;
}

// CompromisedCredential represents a single compromised credential.
message CompromisedCredential {
  // Hashed credential ID (SHA-256) - never the actual vault item ID
  // Used for tracking and correlation without exposing vault structure
  string id_hash = 1;

  // Website or service domain (e.g., "github.com")
  string site = 2;

  // Username or email associated with the credential
  string username = 3;

  // Name of the data breach where credential was found
  string breach_name = 4;

  // Date when breach occurred (Unix seconds)
  int64 breach_date = 5;

  // Date when credential was last rotated (Unix seconds, 0 if never)
  int64 last_rotated = 6;

  // Whether this credential requires Human-in-the-Middle intervention
  // (e.g., due to MFA, CAPTCHA, or ToS restrictions)
  bool requires_him = 7;

  // Severity level of the compromise
  BreachSeverity severity = 8;

  // Additional metadata from password manager
  map<string, string> metadata = 9;

  // Optional: URL for password reset page (if known)
  string reset_url = 10;
}

// BreachSeverity indicates the severity of a credential compromise.
enum BreachSeverity {
  // Default value, should not be used
  BREACH_SEVERITY_UNSPECIFIED = 0;

  // Low severity (minor breach, limited exposure)
  BREACH_SEVERITY_LOW = 1;

  // Medium severity (significant breach, moderate exposure)
  BREACH_SEVERITY_MEDIUM = 2;

  // High severity (major breach, high exposure)
  BREACH_SEVERITY_HIGH = 3;

  // Critical severity (recent breach, active exploitation)
  BREACH_SEVERITY_CRITICAL = 4;
}

// RotateRequest initiates a credential rotation operation.
message RotateRequest {
  // Request metadata for tracing and audit
  Metadata metadata = 1;

  // Hashed credential ID to rotate (from DetectResponse)
  string credential_id_hash = 2;

  // Password generation policy to use
  PasswordPolicy policy = 3;

  // Whether ACVS (compliance validation) is enabled
  // Phase I: Should be false (ACVS is Phase II)
  // Phase II+: Can be true to enable ToS compliance checking
  bool acvs_enabled = 4;

  // Whether to skip rotation if recently rotated
  // If true, check last_rotated timestamp and skip if within threshold
  bool skip_if_recent = 5;

  // Recent rotation threshold in seconds (default: 7 days)
  int64 recent_threshold_seconds = 6;

  // Dry run mode - validate rotation feasibility without making changes
  bool dry_run = 7;
}

// RotateResponse contains the result of a credential rotation.
message RotateResponse {
  // Response status
  Status status = 1;

  // Hashed credential ID that was rotated
  string credential_id_hash = 2;

  // Site/domain of the rotated credential
  string site = 3;

  // New password (only returned in success case)
  // Security: Transmitted over mTLS, should be cleared from client memory after use
  string new_password = 4;

  // Timestamp when rotation completed (Unix seconds)
  int64 rotation_timestamp = 5;

  // Error details if rotation failed
  Error error = 6;

  // Compliance validation result (only if acvs_enabled = true)
  // Phase I: Will be null
  // Phase II+: Contains ToS compliance analysis
  ComplianceValidation compliance = 7;

  // Rotation operation ID for status tracking
  string operation_id = 8;

  // Whether rotation required HIM intervention
  bool required_him = 9;

  // Audit event ID linking to audit log entry
  int64 audit_event_id = 10;
}

// ComplianceValidation contains ToS compliance validation results.
// Phase I: This message is defined but not populated (ACVS is Phase II)
// Phase II+: Populated with Legal NLP analysis results
message ComplianceValidation {
  // Whether automation is allowed by ToS
  bool automation_allowed = 1;

  // Compliance Rule Set (CRC) ID that was applied
  string crc_id = 2;

  // ToS version that was analyzed
  string tos_version = 3;

  // URL of the ToS document
  string tos_url = 4;

  // Validation timestamp (Unix seconds)
  int64 validation_timestamp = 5;

  // List of CRC rules that were evaluated
  repeated string rules_applied = 6;

  // Human-readable reasoning for the decision
  string reasoning = 7;

  // Evidence chain entry ID (for compliance audit)
  string evidence_chain_id = 8;
}

// StatusRequest queries the status of a rotation operation.
message StatusRequest {
  // Request metadata for tracing and audit
  Metadata metadata = 1;

  // Operation ID to check status for
  string operation_id = 2;

  // Credential ID hash to check status for (alternative to operation_id)
  string credential_id_hash = 3;
}

// StatusResponse returns the current status of a rotation operation.
message StatusResponse {
  // Response status
  Status status = 1;

  // Operation ID
  string operation_id = 2;

  // Hashed credential ID
  string credential_id_hash = 3;

  // Current state of the rotation operation
  RotationState state = 4;

  // Progress percentage (0-100)
  int32 progress_percent = 5;

  // Current step description (e.g., "Generating password", "Updating vault")
  string current_step = 6;

  // Timestamp when operation started (Unix seconds)
  int64 started_at = 7;

  // Timestamp when operation completed (Unix seconds, 0 if not complete)
  int64 completed_at = 8;

  // Error details if operation failed
  Error error = 9;

  // Whether operation is waiting for HIM response
  bool awaiting_him = 10;
}

// RotationState represents the current state of a rotation operation.
enum RotationState {
  // Default value, should not be used
  ROTATION_STATE_UNSPECIFIED = 0;

  // Rotation has been queued but not started
  ROTATION_STATE_QUEUED = 1;

  // Rotation is in progress
  ROTATION_STATE_IN_PROGRESS = 2;

  // Rotation is awaiting HIM user input
  ROTATION_STATE_AWAITING_HIM = 3;

  // Rotation completed successfully
  ROTATION_STATE_COMPLETED = 4;

  // Rotation failed
  ROTATION_STATE_FAILED = 5;

  // Rotation was cancelled by user
  ROTATION_STATE_CANCELLED = 6;

  // Rotation timed out
  ROTATION_STATE_TIMEOUT = 7;
}

// ListRequest retrieves credentials from the password vault.
message ListRequest {
  // Request metadata for tracing and audit
  Metadata metadata = 1;

  // Password manager type to query
  PasswordManagerType password_manager_type = 2;

  // Optional filter to limit results
  ListFilter filter = 3;

  // Pagination parameters
  PaginationRequest pagination = 4;
}

// ListFilter allows filtering credential list results.
message ListFilter {
  // Filter by specific domains
  repeated string domains = 1;

  // Filter by categories
  repeated string categories = 2;

  // Only return compromised credentials
  bool only_compromised = 3;

  // Search query (matches site, username, or notes)
  string search_query = 4;
}

// ListResponse returns a list of credentials.
message ListResponse {
  // Response status
  Status status = 1;

  // List of credential metadata (passwords NOT included)
  repeated CredentialMetadata credentials = 2;

  // Pagination information
  PaginationResponse pagination = 3;

  // Error details if status is not SUCCESS
  Error error = 4;
}

// CredentialMetadata contains non-sensitive credential information.
message CredentialMetadata {
  // Hashed credential ID
  string id_hash = 1;

  // Site/domain
  string site = 2;

  // Username
  string username = 3;

  // Category (e.g., "login", "identity", "secure_note")
  string category = 4;

  // Whether credential is compromised
  bool is_compromised = 5;

  // Last modified timestamp (Unix seconds)
  int64 last_modified = 6;

  // Last rotated timestamp (Unix seconds, 0 if never)
  int64 last_rotated = 7;

  // Additional metadata
  map<string, string> metadata = 8;
}

// GeneratePasswordRequest requests generation of a secure password.
message GeneratePasswordRequest {
  // Request metadata for tracing and audit
  Metadata metadata = 1;

  // Password policy to use
  PasswordPolicy policy = 2;

  // Number of passwords to generate (default: 1, max: 10)
  int32 count = 3;
}

// GeneratePasswordResponse returns generated passwords.
message GeneratePasswordResponse {
  // Response status
  Status status = 1;

  // Generated passwords
  repeated string passwords = 2;

  // Entropy bits of generated passwords
  float entropy_bits = 3;

  // Error details if status is not SUCCESS
  Error error = 4;
}
